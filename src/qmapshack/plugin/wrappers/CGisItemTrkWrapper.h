/**********************************************************************************************

This file was autogenerated by src/qmapshack/plugin/wrappers/createWrapper.py

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

**********************************************************************************************/

#ifndef CGISITEMTRKWRAPPER_H
#define CGISITEMTRKWRAPPER_H

#include <qobject.h>
#include "gis/trk/CGisItemTrk.h"

class IGisItem;
 using selflags_t = quint32;
class CActivityTrk;
class CPropertyTrk;


class CGisItemTrkWrapper : public QObject
 {
    Q_OBJECT
public slots:
    void updateHistory(CGisItemTrk* wrappedObj, quint32  visuals) { return wrappedObj->updateHistory(visuals);}
    void updateVisuals(CGisItemTrk* wrappedObj, quint32  visuals, const QString & who) { return wrappedObj->updateVisuals(visuals, who);}
    IGisItem * createClone(CGisItemTrk* wrappedObj) { return wrappedObj->createClone();}
    void save(CGisItemTrk* wrappedObj, QDomNode&  gpx, bool  strictGpx11) { return wrappedObj->save(gpx, strictGpx11);}
    bool saveTwoNav(CGisItemTrk* wrappedObj, const QString&  filename) { return wrappedObj->saveTwoNav(filename);}
    void saveTCXcourse(CGisItemTrk* wrappedObj, QDomNode&  coursesNode) { return wrappedObj->saveTCXcourse(coursesNode);}
    void saveTCXactivity(CGisItemTrk* wrappedObj, QDomNode&  activitiesNode) { return wrappedObj->saveTCXactivity(activitiesNode);}
    const QString& getName(CGisItemTrk* wrappedObj) { return wrappedObj->getName();}
    bool isTrkTimeValid(CGisItemTrk* wrappedObj) { return wrappedObj->isTrkTimeValid();}
    bool isTrkElevationInvalid(CGisItemTrk* wrappedObj) { return wrappedObj->isTrkElevationInvalid();}
    bool isTrkSlopeInvalid(CGisItemTrk* wrappedObj) { return wrappedObj->isTrkSlopeInvalid();}
    QDateTime getTimestamp(CGisItemTrk* wrappedObj) { return wrappedObj->getTimestamp();}
    int getColorIdx(CGisItemTrk* wrappedObj) { return wrappedObj->getColorIdx();}
    const QColor& getColor(CGisItemTrk* wrappedObj) { return wrappedObj->getColor();}
    QString getInfo(CGisItemTrk* wrappedObj, quint32  feature) { return wrappedObj->getInfo(feature);}
    QString getInfoRange(CGisItemTrk* wrappedObj) { return wrappedObj->getInfoRange();}
    QString getInfoLimits(CGisItemTrk* wrappedObj) { return wrappedObj->getInfoLimits();}
    quint32 getTotalElapsedSeconds(CGisItemTrk* wrappedObj) { return wrappedObj->getTotalElapsedSeconds();}
    quint32 getTotalElapsedSecondsMoving(CGisItemTrk* wrappedObj) { return wrappedObj->getTotalElapsedSecondsMoving();}
    qreal getTotalAscent(CGisItemTrk* wrappedObj) { return wrappedObj->getTotalAscent();}
    qreal getTotalDescent(CGisItemTrk* wrappedObj) { return wrappedObj->getTotalDescent();}
    qreal getTotalDistance(CGisItemTrk* wrappedObj) { return wrappedObj->getTotalDistance();}
    qint32 getCntTotalPoints(CGisItemTrk* wrappedObj) { return wrappedObj->getCntTotalPoints();}
    const QDateTime& getTimeStart(CGisItemTrk* wrappedObj) { return wrappedObj->getTimeStart();}
    const QDateTime& getTimeEnd(CGisItemTrk* wrappedObj) { return wrappedObj->getTimeEnd();}
    qint32 getNumberOfVisiblePoints(CGisItemTrk* wrappedObj) { return wrappedObj->getNumberOfVisiblePoints();}
    qint32 getNumberOfInvalidPoints(CGisItemTrk* wrappedObj) { return wrappedObj->getNumberOfInvalidPoints();}
    const CActivityTrk& getActivities(CGisItemTrk* wrappedObj) { return wrappedObj->getActivities();}
    const CPropertyTrk * getPropertyHandler(CGisItemTrk* wrappedObj) { return wrappedObj->getPropertyHandler();}
    quint32 getAllValidFlags(CGisItemTrk* wrappedObj) { return wrappedObj->getAllValidFlags();}
    void getPolylineFromData(CGisItemTrk* wrappedObj, QPolygonF & l) { return wrappedObj->getPolylineFromData(l);}
    void getPolylineFromData(CGisItemTrk* wrappedObj, SGisLine&  l) { return wrappedObj->getPolylineFromData(l);}
    void getPolylineDegFromData(CGisItemTrk* wrappedObj, QPolygonF & l) { return wrappedObj->getPolylineDegFromData(l);}
    qint32 getElevation(CGisItemTrk* wrappedObj, qint32  idx) { return wrappedObj->getElevation(idx);}
    void getMouseRange(CGisItemTrk* wrappedObj, int & idx1, int & idx2, bool  total) { return wrappedObj->getMouseRange(idx1, idx2, total);}
    const searchValue_t getValueByKeyword(CGisItemTrk* wrappedObj, searchProperty_e  keyword) { return wrappedObj->getValueByKeyword(keyword);}
    void setColorizeSource(CGisItemTrk* wrappedObj, QString  src) { return wrappedObj->setColorizeSource(src);}
    QString getColorizeSource(CGisItemTrk* wrappedObj) { return wrappedObj->getColorizeSource();}
    QStringList getExistingDataSources(CGisItemTrk* wrappedObj) { return wrappedObj->getExistingDataSources();}
    void setColorizeLimitLow(CGisItemTrk* wrappedObj, qreal  limit) { return wrappedObj->setColorizeLimitLow(limit);}
    qreal getColorizeLimitLow(CGisItemTrk* wrappedObj) { return wrappedObj->getColorizeLimitLow();}
    void setColorizeLimitHigh(CGisItemTrk* wrappedObj, qreal  limit) { return wrappedObj->setColorizeLimitHigh(limit);}
    qreal getColorizeLimitHigh(CGisItemTrk* wrappedObj) { return wrappedObj->getColorizeLimitHigh();}
    QString getColorizeUnit(CGisItemTrk* wrappedObj) { return wrappedObj->getColorizeUnit();}
    qreal getMin(CGisItemTrk* wrappedObj, const QString&  source) { return wrappedObj->getMin(source);}
    qreal getMax(CGisItemTrk* wrappedObj, const QString&  source) { return wrappedObj->getMax(source);}
};

class INotifyTrkWrapper : public QObject
 {
    Q_OBJECT
public slots:
    virtual void updateData(INotifyTrk* wrappedObj) { return wrappedObj->updateData();}
}; 

#endif