"""
/**********************************************************************************************
    Copyright (C) 2020 Henri Hornburg <hrnbg@t-online.de>
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

**********************************************************************************************/
"""
import re
import sys

patchLines = dict()
patchLines["class IGisItem;\n"] = "class IGisItem;\nusing selflags_t = quint32;\n"

if __name__ == "__main__":

    # The c++ file we want to parse
    fileToWrap = sys.argv[1]
    fileToWrap_short = re.search(r"/(([\w]+/)*[\w]+\.h)", fileToWrap).group(1)
    wrapperFileH = re.search(r"/([\w]+)\.h", fileToWrap).group(1) + "Wrapper.h"
    print("plugin/wrappers/" + wrapperFileH)

    copyNotice = "/**********************************************************************************************\n" \
                 "\n"\
                 "This file was autogenerated by src/qmapshack/plugin/wrappers/createWrapper.py\n" \
                 "\n" \
                 "This program is free software: you can redistribute it and/or modify\n" \
                 "it under the terms of the GNU General Public License as published by\n" \
                 "the Free Software Foundation, either version 3 of the License, or\n" \
                 "(at your option) any later version.\n" \
                 "\n" \
                 "This program is distributed in the hope that it will be useful,\n" \
                 "but WITHOUT ANY WARRANTY; without even the implied warranty of\n" \
                 "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" \
                 "GNU General Public License for more details.\n" \
                 "\n" \
                 "You should have received a copy of the GNU General Public License\n" \
                 "along with this program.  If not, see <http://www.gnu.org/licenses/>.\n" \
                 "\n" \
                 "**********************************************************************************************/\n\n"
    # Create head and foot of file
    headOfFile = copyNotice
    headOfFile += "#ifndef " + wrapperFileH.upper().replace(".", "_") + "\n"
    headOfFile += "#define " + wrapperFileH.upper().replace(".", "_") + "\n\n"
    headOfFile += '#include <qobject.h>\n'
    headOfFile += '#include "' + fileToWrap_short + '"\n\n'

    footOfFile = "}; \n\n#endif"

    # parse file
    bodyOfFile = ""
    className = None
    classAnchestry = []
    classScopeDepth = 0
    classAnchestries = dict()
    currentScopeDepth = 0
    public = False
    inComment = 0
    with open(fileToWrap) as infile:
        for line in infile:
            commentEndSearch = re.search(r"\*/", line)
            if commentEndSearch is not None:
                inComment -= 1
            commentBeginSearch = re.search(r"/\*", line)
            if commentBeginSearch is not None:
                inComment += 1
            if inComment > 0:
                continue

            classSearch = re.match(r"\s*class ([\w]+)", line)
            if classSearch is not None:
                if ";" in line:
                    continue  # These are forward declarations and friend classes
                if len(bodyOfFile) != 0:
                    bodyOfFile += "};\n\n"

                # Save data of new class
                classScopeDepth = currentScopeDepth
                # Do this before new assignment of className to avoid current class being in anchestry
                if className is not None:
                    classAnchestry.append(className)
                className = classSearch.group(1)
                classAnchestries[className] = classAnchestry

                public = False
                bodyOfFile += "class " + className + "Wrapper : public QObject\n {\n    Q_OBJECT\npublic slots:\n"
                continue

            # for now don't wrap structs
            structSearch = re.match(r"\s*struct ([\w]+)", line)
            if structSearch is not None:
                if ";" in line:
                    continue  # These are forward declarations and friend structs
                classAnchestries[structSearch.group(1)] = classAnchestry + [className]
                continue

            enumSearch = re.match(r"\s*enum ([\w]+)", line)
            if enumSearch is not None:
                if ";" in line:
                    continue  # These are forward declarations
                classAnchestries[enumSearch.group(1)] = classAnchestry + [className]
                continue

            if re.search(r"{", line):
                currentScopeDepth += 1

            if re.search(r"}", line):
                currentScopeDepth -= 1
                if currentScopeDepth == classScopeDepth:
                    if len(classAnchestry) > 0:
                        classAnchestry.pop(len(classAnchestry) - 1)
                    if len(classAnchestry) == 0:
                        className = None
                    else:
                        className = classAnchestry[len(classAnchestry) - 1]

            publicSearch = re.search(r"public:|public slots:", line)
            if publicSearch is not None:
                public = True
                continue

            doNotWrapSearch = re.search(r"private:|protected:|private slots:|protected slots:|signals", line)
            if doNotWrapSearch is not None:
                public = False
                continue

            if not public or currentScopeDepth != classScopeDepth + 1 or className is None:
                continue

#            usingSearch = re.match(r"\s* using", line)
#            if usingSearch is not None:
#                headOfFile += line
#                continue

            methodSearchRegex = r"\s*([\w]*? *([\w]+) *[&*]*) "  # Return type
            methodSearchRegex += r"([\w]+)\("  # Method name and opening brace
            matchParameter = r"([\w]*? *([\w]+) *[&*]* *)([\w]+)"
            methodSearchRegex += r"((" + matchParameter + r", )*)(" + matchParameter + r"){0,1}\)"  # Parameter list

            methodSearch = re.match(methodSearchRegex, line)
            if methodSearch is not None:
                returnType = methodSearch.group(1)
                if returnType == "return":
                    # should not happen
                    print("detected return as method. Please check script.")
                    continue
                returnTypeName = methodSearch.group(2)
                returnTypeSearch = re.match(r"[IC][\w]+", returnTypeName)
                if returnTypeSearch is not None:
                    hofLineToAdd = "class " + returnTypeSearch.group(0) + ";\n"
                    if hofLineToAdd in patchLines.keys():
                        hofLineToAdd = patchLines[hofLineToAdd]
                    headOfFile += hofLineToAdd

                # Check Method name
                methodName = methodSearch.group(3)
                if methodName == className:
                    continue  # do not autogenerate constructors for now

                # Retrieve Parameters
                paramNameList = []
                paramTypeList = []
                paramTypeNameList = []
                for param in methodSearch.group(4).split(", "):
                    paramRe = re.match(matchParameter + "$", param)
                    if paramRe is None:
                        continue
                    paramNameList.append(paramRe.group(3))
                    paramTypeList.append(paramRe.group(1))
                    paramTypeNameList.append(paramRe.group(2))
                if methodSearch.group(9) is not None:
                    paramNameList.append(methodSearch.group(12))
                    paramTypeList.append(methodSearch.group(10))
                    paramTypeNameList.append(methodSearch.group(11))

                # generate line
                if returnTypeName in classAnchestries.keys():
                    returnType = returnType.replace(returnTypeName,
                                                    "::".join(classAnchestries[returnTypeName]) + "::" + returnTypeName)
                wrappedMethod = "    " + returnType + " " + methodName + "(" + className + "* wrappedObj"

                for i in range(len(paramNameList)):
                    if paramTypeNameList[i] in classAnchestries.keys():
                        paramType = paramTypeList[i].replace(paramTypeNameList[i],
                                                             "::".join(classAnchestries[paramTypeNameList[i]]) +
                                                             "::" + paramTypeNameList[i])
                    else:
                        paramType = paramTypeList[i]
                    wrappedMethod += ", " + paramType + " " + paramNameList[i]
                wrappedMethod += ") { return wrappedObj->" + methodName + "("
                for i in range(len(paramNameList)):
                    if i > 0:
                        wrappedMethod += ", "
                    wrappedMethod += paramNameList[i]
                wrappedMethod += ");}\n"

                bodyOfFile += wrappedMethod

    with open(wrapperFileH, "w") as outfile:
        outfile.write(headOfFile + "\n\n")
        outfile.write(bodyOfFile)
        outfile.write(footOfFile)

